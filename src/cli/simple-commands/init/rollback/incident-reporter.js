
// incident-reporter.js - Generate rollback incident reports

import { promises as fs } from 'fs';

export class IncidentReporter {
  constructor(workingDir) {
    this.workingDir = workingDir;
    this.reportsDir = `${workingDir}/.claude-flow-incidents`;
  }

  /**
   * Generate a rollback incident report
   */
  async generateIncidentReport(rollbackData, options = {}) {
    const result = {
      success: true,
      reportId: null,
      reportPath: null,
      errors: [],
    };

    try {

      await this.ensureReportsDir();

      const timestamp = new Date().toISOString();
      const reportId = `incident-${timestamp.replace(/[:.TZ]/g, '-')}`;
      result.reportId = reportId;

      const reportPath = `${this.reportsDir}/${reportId}.md`;
      result.reportPath = reportPath;

      const report = await this.formatIncidentReport(rollbackData, timestamp, options);
      await fs.writeFile(reportPath, report, 'utf8');

      // Also create JSON metadata
      const metadata = {
        id: reportId,
        timestamp,
        type: 'rollback_incident',
        severity: rollbackData.severity || 'Medium',
        status: rollbackData.status || 'investigating',
        rollbackSessionId: rollbackData.sessionId,
        sourceCommit: rollbackData.sourceCommit,
        targetCommit: rollbackData.targetCommit,
        reason: rollbackData.reason,
      };

      await fs.writeFile(
        `${this.reportsDir}/${reportId}.json`,
        JSON.stringify(metadata, null, 2),
        'utf8'
      );

      console.log(`ðŸ“‹ Incident report generated: ${reportPath}`);

    } catch (error) {
      result.success = false;
      result.errors.push(`Failed to generate incident report: ${error.message}`);
    }

    return result;
  }

  /**

   * Format the incident report using the template structure
   */
  async formatIncidentReport(data, timestamp, options = {}) {
    const {
      incidentType = 'Manual Rollback',
      severity = 'Medium',
      status = 'Investigating',
      sessionId = 'manual',
      sourceCommit = 'unknown',
      targetCommit = 'unknown',
      reason = 'Manual rollback requested',
      userImpact = 'Unknown',
      duration = 'Unknown',
      components = ['Application'],
    } = data;

    const timeStr = timestamp.split('T')[1].split('.')[0];
    const dateStr = timestamp.split('T')[0];

    return `# ðŸ”„ Rollback Incident Report

**Generated:** ${timestamp}  
**Report ID:** ${sessionId}  

## ðŸ”„ Rollback Incident Details

### Incident Summary
- **Incident Type:** ${incidentType}
- **Severity:** ${severity}
- **Status:** ${status}
- **Detected At:** ${dateStr} ${timeStr} UTC

### Rollback Information
- **Rollback Session ID:** ${sessionId}
- **Source Commit:** ${sourceCommit}
- **Target Commit:** ${targetCommit}
- **Rollback Reason:** ${reason}

### Impact Assessment
- [ ] Production services affected
- [ ] User-facing functionality impacted

- [ ] Data integrity concerns
- [ ] Performance degradation
- [ ] Security implications

**Affected Components:**

${components.map(c => `- ${c}`).join('\n')}


**Estimated User Impact:**
- **Users Affected:** ${userImpact}
- **Duration:** ${duration}

### Timeline

<!-- Provide a timeline of events -->

**Detection:**
- ${dateStr} ${timeStr}: Issue detected${options.automated ? ' by automated monitoring' : ''}

**Rollback Execution:**
- ${dateStr} ${timeStr}: Rollback initiated
- <!-- When was rollback completed -->

**Resolution:**
- <!-- When was normal service restored -->

### Root Cause Analysis
<!-- What caused the original failure that required rollback -->

**Contributing Factors:**
- ${reason}

**Failure Points:**
- <!-- Identify where systems failed to prevent this -->

### Resolution Actions
<!-- What was done to resolve the incident -->

- [ ] Automated rollback executed successfully
- [ ] Manual intervention required
- [ ] Database rollback performed
- [ ] Configuration restored
- [ ] Monitoring alerts configured

### Prevention Measures
<!-- What will be done to prevent similar incidents -->

**Immediate Actions:**
- [ ] <!-- Immediate steps taken -->

**Long-term Improvements:**
- [ ] <!-- Process/system improvements -->

### Lessons Learned
<!-- Key takeaways from this incident -->

1. <!-- Lesson 1 -->
2. <!-- Lesson 2 -->
3. <!-- Lesson 3 -->

### Follow-up Actions
<!-- Actions to be taken after incident resolution -->

- [ ] Update rollback procedures
- [ ] Improve monitoring/alerting
- [ ] Enhance testing procedures
- [ ] Update documentation
- [ ] Team training/communication

### Stakeholder Communication
<!-- How stakeholders were informed -->

- [ ] Team notified
- [ ] Management informed
- [ ] Users communicated (if applicable)
- [ ] Post-mortem scheduled

---

**Additional Notes:**

${options.notes || 'Local rollback incident report generated by claude-flow rollback system.'}

**Related Issues/PRs:**
<!-- Link related issues or pull requests -->

**Rollback Artifacts:**
- Report ID: ${sessionId}
- Report generated: ${timestamp}
- Working directory: ${this.workingDir}
`;
  }

  /**
   * List incident reports
   */
  async listIncidentReports() {
    const result = {
      success: true,
      reports: [],
      errors: [],
    };

    try {
      await this.ensureReportsDir();

      const files = await fs.readdir(this.reportsDir);
      const reportFiles = files.filter(f => f.endsWith('.json'));

      for (const file of reportFiles) {
        try {
          const content = await fs.readFile(`${this.reportsDir}/${file}`, 'utf8');
          const metadata = JSON.parse(content);
          result.reports.push(metadata);
        } catch (error) {
          result.errors.push(`Failed to read report ${file}: ${error.message}`);
        }
      }

      result.reports.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    } catch (error) {
      result.success = false;
      result.errors.push(`Failed to list incident reports: ${error.message}`);
    }

    return result;
  }

  /**
   * Get a specific incident report
   */
  async getIncidentReport(reportId) {
    const result = {
      success: true,
      report: null,
      metadata: null,
      errors: [],
    };

    try {

      const metadataPath = `${this.reportsDir}/${reportId}.json`;
      const reportPath = `${this.reportsDir}/${reportId}.md`;

      // Read metadata
      const metadataContent = await fs.readFile(metadataPath, 'utf8');
      result.metadata = JSON.parse(metadataContent);

      // Read report
      result.report = await fs.readFile(reportPath, 'utf8');
    } catch (error) {
      result.success = false;
      result.errors.push(`Failed to get incident report: ${error.message}`);
    }

    return result;
  }

  /**
   * Create GitHub issue from incident report
   */
  async createGitHubIssue(reportId, options = {}) {
    const result = {
      success: true,
      issueUrl: null,
      issueNumber: null,
      errors: [],
      warnings: [],
    };

    try {
      const reportData = await this.getIncidentReport(reportId);
      if (!reportData.success) {
        result.success = false;
        result.errors.push(...reportData.errors);
        return result;
      }

      const {
        owner = 'g2goose',
        repo = 'claude-flow',
        assignees = ['copilot'],
        labels = ['rollback', 'incident', 'high-priority'],
        useAPI = true
      } = options;

      const metadata = reportData.metadata;
      const reportContent = reportData.report;

      // Prepare issue data
      const issueTitle = `ðŸ”„ Rollback Incident: ${metadata.reason || 'Automated rollback incident'}`;
      const issueData = {
        title: issueTitle,
        body: reportContent,
        labels: labels,
        assignees: assignees
      };

      // Try GitHub API first, then fall back to CLI
      if (useAPI && process.env.GITHUB_TOKEN) {
        const apiResult = await this._createIssueWithAPI(owner, repo, issueData);
        if (apiResult.success) {
          result.issueUrl = apiResult.url;
          result.issueNumber = apiResult.number;
          console.log(`âœ… GitHub issue created: ${result.issueUrl}`);
          return result;
        } else {
          result.warnings.push(`API creation failed: ${apiResult.error}`);
        }
      }

      // Try GitHub CLI as fallback
      const cliResult = await this._createIssueWithCLI(owner, repo, issueData);
      if (cliResult.success) {
        result.issueUrl = cliResult.url;
        result.issueNumber = cliResult.number;
        console.log(`âœ… GitHub issue created via CLI: ${result.issueUrl}`);
        return result;
      } else {
        result.warnings.push(`CLI creation failed: ${cliResult.error}`);
      }

      // If both methods failed, provide manual instructions
      result.success = false;
      result.errors.push('Both GitHub API and CLI creation failed');
      result.warnings.push('Please create the issue manually:');
      result.warnings.push(`Title: ${issueTitle}`);
      result.warnings.push(`Report content available at: ${this.reportsDir}/${reportId}.md`);
      result.warnings.push(`Assign to: ${assignees.join(', ')}`);
      result.warnings.push(`Labels: ${labels.join(', ')}`);

    } catch (error) {
      result.success = false;
      result.errors.push(`Failed to create GitHub issue: ${error.message}`);
    }

    return result;
  }

  /**
   * Create GitHub issue using REST API
   * @private
   */
  async _createIssueWithAPI(owner, repo, issueData) {
    const result = {
      success: false,
      url: null,
      number: null,
      error: null
    };

    try {
      const token = process.env.GITHUB_TOKEN;
      if (!token) {
        result.error = 'GITHUB_TOKEN environment variable is required';
        return result;
      }

      const url = `https://api.github.com/repos/${owner}/${repo}/issues`;
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
          'User-Agent': 'claude-flow-incident-reporter'
        },
        body: JSON.stringify(issueData)
      });

      if (!response.ok) {
        const errorText = await response.text();
        result.error = `API Error ${response.status}: ${errorText}`;
        return result;
      }

      const issueResult = await response.json();
      result.success = true;
      result.url = issueResult.html_url;
      result.number = issueResult.number;

    } catch (error) {
      result.error = error.message;
    }

    return result;
  }

  /**
   * Create GitHub issue using CLI
   * @private
   */
  async _createIssueWithCLI(owner, repo, issueData) {
    const result = {
      success: false,
      url: null,
      number: null,
      error: null
    };

    try {
      const { execSync } = await import('child_process');
      
      const args = [
        'issue', 'create',
        '--repo', `${owner}/${repo}`,
        '--title', issueData.title,
        '--body', issueData.body
      ];

      if (issueData.labels && issueData.labels.length > 0) {
        args.push('--label', issueData.labels.join(','));
      }

      if (issueData.assignees && issueData.assignees.length > 0) {
        args.push('--assignee', issueData.assignees.join(','));
      }

      const spawnResult = spawnSync('gh', args, {
        encoding: 'utf-8',
        timeout: 30000
      });
      const output = spawnResult.stdout;
      if (spawnResult.error) {
        throw spawnResult.error;
      }

      // Extract URL from output
      const urlMatch = output.match(/https:\/\/github\.com\/[^\s]+/);
      if (urlMatch) {
        result.success = true;
        result.url = urlMatch[0];
        
        // Extract issue number from URL
        const numberMatch = result.url.match(/\/issues\/(\d+)$/);
        if (numberMatch) {
          result.number = parseInt(numberMatch[1]);
        }
      } else {
        result.error = 'Could not parse issue URL from CLI output';
      }

    } catch (error) {
      result.error = error.message;
    }

    return result;
  }

  // Helper methods

  /**
   * Generate a rollback incident report with automatic GitHub issue creation
   */
  async generateRollbackIncidentReport(rollbackData, options = {}) {
    const result = {
      success: true,
      reportId: null,
      reportFile: null,
      issueUrl: null,
      errors: [],
      warnings: [],
    };

    try {
      // Generate the incident report first
      const reportResult = await this.generateIncidentReport(rollbackData, options);
      
      if (!reportResult.success) {
        result.success = false;
        result.errors.push(...reportResult.errors);
        return result;
      }

      result.reportId = reportResult.reportId;
      result.reportFile = reportResult.reportPath;

      // Automatically create GitHub issue if enabled
      if (options.createGitHubIssue !== false) {
        const issueResult = await this.createGitHubIssue(result.reportId, options);
        
        if (issueResult.success) {
          result.issueUrl = issueResult.issueUrl;
          console.log(`ðŸŽ¯ GitHub issue created and assigned to @copilot: ${result.issueUrl}`);
        } else {
          result.warnings.push(...(issueResult.warnings || []));
          result.warnings.push(...(issueResult.errors || []));
        }
      }

    } catch (error) {
      result.success = false;
      result.errors.push(`Failed to generate rollback incident report: ${error.message}`);
    }

    return result;
  }

  /**
   * Validate incident report data
   */
  validateIncidentData(data) {
    const errors = [];
    const warnings = [];

    // Required fields
    if (!data.sessionId) {
      errors.push('sessionId is required for incident reports');
    }

    if (!data.reason) {
      warnings.push('reason not provided - using default');
    }

    // Validate severity level
    const validSeverities = ['Critical', 'High', 'Medium', 'Low'];
    if (data.severity && !validSeverities.includes(data.severity)) {
      warnings.push(`Invalid severity level: ${data.severity}. Using default.`);
    }

    // Validate incident type
    const validTypes = ['Manual Rollback', 'Automated Rollback', 'Emergency Rollback', 'Rollback Failure'];
    if (data.incidentType && !validTypes.includes(data.incidentType)) {
      warnings.push(`Invalid incident type: ${data.incidentType}. Using default.`);
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  async ensureReportsDir() {
    try {
      await fs.mkdir(this.reportsDir, { recursive: true });
    } catch (error) {
      if (error.code !== 'EEXIST') {
        throw error;
      }
    }
  }
}